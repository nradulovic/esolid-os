/** @file */
/** @defgroup   evt Event Management */
/** @{
@defgroup       evt_intf API
@defgroup       evt_impl Implementation
@defgroup       evt_cfg  Configuration
@}
*/
/** @addtogroup evt
@brief          Event object overview

@section        evt_index Sadrzaj
- @ref evt_intro
- @ref evt_database
    - @ref evt_db_create
    - @ref evt_db_reg
- @ref evt_configuration

@section        evt_intro Dogadjaj i prelazak
Događaj je pojava stimulusa koji može da okine promenu stanja i koji je značajan 
objektu ili aplikaciji.

Kao što se skup objekata definiše klasom čiji su oni uzorci, događaji se 
definišu tipom događaja čije uzorke predstavljaju događaji.

Ono što se modeluje zapravo su tipovi događaja, ali jednostavno ih zovemo 
događajima.

Događaj može imati parametre 

@section        evt_database Baza dogadjaja

eSolid definise centralizovanu bazu dogadjaja koji se koriste u sistemu. Baza 
dogadjaja omogucuje efikasno i jednostavno opisivanje dogadjaja. Podaci su 
staticni, ne menjaju se u toku izvrsavanja aplikacije i zbog toga se podaci mogu 
cuvati u ROM tipu memorije. Baza dogadjaja definise sledece aspekte dogadjaja:
- znakovni identifikator: u C-u se identifikator implementira kao enumerator
- velicinu dogadjaja: za svaki tip dogadjaja se cuva velicina dogadjaja u 
    bajtovima
- memorijsko skladiste dogadjaja: memorijski prostor dogadjaja se moze dobaviti
    upotrebom @c dinamickog alokatora ili upotrebom @c pool alokatora. Ako se
    koristi @c pool alokator onda ovaj clan elementa baze dogadjaja cuva koja
    instanca @c pool alokatora cuva dati tip dogadjaja.
- tip dogadjaja: definise se C tip dogadjaja za svaki dogadjaj. Nekoliko 
    dogadjaja mogu imati isti tip.
- znakovni niz tipa dogadjaja: pored C tipa dogadjaja definise se znakovni niz
    koji se koristi za debug-ovanje
- znakovni niz opisa dogadjaja: kratak opis dogadjaja, sta on radi i za sta se
    koristi.
    
Baza dogadjaja omogucuje eSolid-u da jednostavno poveze identifikator dogadjaja 
sa njegovim ostalim atributuma. Naime, ako se eSolid-u preda samo identifikator 
dogadjaja, on moze da iz baze dogadjaja dobavi ostale atribute o dogadjaju kao 
sto je velicina, memorijsko skladiste, tip, opis dogadjaja i slicno.

@subsection     evt_db_create Kreiranje i popunjavanje baze dogadjaja

Za implementaciju baze dogadjaja koriste se takozvani <i>X makroi</i>. X 
makroima se vrlo jednostavno generise baza dogadjaja i ne postoji mogucnost da 
se pojavi nesklad izmedju identifikatora dogadjaja i ostalih atributa o 
dogadjaju.

Kreiranje i popunjavanje baze dogadjaja se vrsi u nekoliko koraka:
- @ref evtc_step_1
- @ref evtc_step_2
- @ref evtc_step_3
- @ref evtc_step_4

@subsubsection  evtc_step_1 Korak 1: Definisanje tipova
Najpre se vrsi definisanje tipova dogadjaja. Tipovi dogadjaja su samo one 
struktrure koje su izvedene iz osnovne strukture dogadjaja @ref esEvt_T. 
Definisanje se radi na sledeci nacin:
- razmatra se sta je potrebno da dogadjaj prenese, odnosno, koje informacije
    neki dogadjaj treba da nosi sa sobom. Ove informacije se zovu parametri
    dogadjaja.
- kreira se struktura koja nosi ime novog tipa dogadjaja, sa elementima koji su
    odredjeni u prethodnom koraku. Zatim se tim elementima dodaje element 
    zaglavlja dogadjaja @ref esEvt_T koji mora da bude na prvoj poziciji. Ime
    tog elementa nije od znacaja, ali se preporucuju imena kao sto su @c super 
    ili @c header.
    
Primer 1:
- Dogadjaj treba da prenese jedan 32-bitni neoznaceni podatak. Ime novog tipa 
    dogadjaja neka je @c simpleEvt_T.

@code
typedef struct simpleEvt {
    esEvt_T         super;
    uint32_t        data;
} simpleEvt_T;
@endcode
<i>Listing 1</i> - Primer tipa dogadjaja sa jednim parametrom

Primer 2:
- Dogadjaj treba da prenese dva podatka, jedan je 8-bitni, a drugi 16-bitni.
    Oba podatka su neoznacena. Ukoliko je raspored podataka unutar strukture 
    nebitan, onda se preporucuje da se prvo navedu podaci koji zauzimaju veci 
    broj bajtiova, a zatim se navode podaci sa manjim zauzecem. Ovo pomaze 
    kompajlerima da kompaktnije organizuju strukture. Neka je ime novog tipa 
    dogadjaja @c moreComplex_T.
    
@code
typedef struct moreComplex {
    esEvt_T         super;
    uint16_t        data1;
    uint8_t         data2;
} moreComplex_T;
@endcode
<i>Listing 2</i> - Primer tipa dogadjaja sa dva parametra

Primer 3:
- Dogadjaj ne treba da prenese ni jedan parametar. Uglavnom se ovakvi dogadjaji
koriste samo za signalizaciju. Neka je tip takvog dogadjaja @c basicEvt_T.

@code
typedef struct basicEvt {
    esEvt_T         super;
} basicEvt_T;
@endcode
<i>Listing 3</i> - Primer tipa dogadjaja bez parametra

@subsubsection  evtc_step_2 Korak 2: Definisanje memorijskog skladista
Svaka instanca dogadjaja zahteva memorijski prostor. Memorijski prostor se moze
dobaviti upotrebom dva memorijska alokatora, @c dinamicki alokator i @c pool
alokator. @c Dinamicki alokator moze da alocira memorijske regione sa 
promenljivom velicinom, dok @c pool alokator alocira memoriju samo u blokovima 
fiksne velicine. 

- Dinamicki alokator je vrlo slican standardnoj biblioteckoj funkciji @c malloc
sa tom razlikom sto je optimizovan za embedded okruzenje. Medjutim, upotreba 
dinamickog alokatora nije uvek pozeljna u embedded okruzenju zbog nemogucnosti
dokazivanja da ce alokator uvek uspesno opsluziti zahteve za dobavljanje 
memorije.
- Pool alokator je dosta jednostavniji od dinamickog alokatora, ne postoji 
mogucnost pojave fragmentacije memorije i vreme izvrsenja je uvek poznato. 
Glavna negativna osobina je da ne moze da alocira delove memorije vece od 
predefinisane velicine bloka.
 
Ako se koristi pool alokator onda treba kreirati potrebne instance pool 
alokatora (pogledati @ref page_mem), a zatim se deskriptori pool memorija navode
u makro tabeli.

Ukoliko je potrebno da neki dogadjaj ima promenljivu velicinu onda se moze
koristiti dinamicki alokator. U tom slucaju se samo postavlja @c NULL vrednost
umesto pokazivaca na instancu pool alokatora. Dinamicki alokator se 
inicijalizuje na sledeci nacin:

@code

    :
    :

#define BUFFER_SIZE                     1024

    :
    
static char buffer[BUFFER_SIZE];
esDMemInit(
    &gEvtDynStorage,
    &buffer[0],
    sizeof(buffer));
@endcode

@note           Pogledati opcije @ref OPT_EVT_USE_MEM_POOL i 
                @ref OPT_EVT_USE_MEM_DYN kojima se ukljucuje/iskljucuje koji
                alokatori se koriste.
                
@subsubsection  evtc_step_3 Korak 3: Popunjavanje atributa
Nakon definisanja tipova dogadjaja vrsi se popunjavanje svih atributa dogadjaja 
u makro tabelu. 

@code
#define EVENT_TABLE(table)                                                      \
    table({id},     {type},         {storage},  "description")
@endcode
<i>Listing 4a</i> - Format makro tabele 
- @c id - identifikator dogadjaja, tip podatka je @ref esEvtId_T
- @c type - struktura dogadjaja kreirana u @ref evtc_step_1
- @c storage - pokazivac na memorijsko skladiste dogadjaja kreirano u 
    @ref evtc_step_1,
- @c description - znakovni niz kratkog opisa dogadjaja, sta on radi i za sta se
    koristi
    
Podaci se upisuju u makro tabelu na sledeci nacin:

@code
#define EVENT_TABLE(table)                                                      \
    table(ID1,      simpleEvt_T,    NULL,       "This is a very simple event")  \
    table(ID2,      basicEvt_T,     NULL,       "A signal event")
@endcode
<i>Listing 4b</i> - Primer makro tabele sa dva dogadjaja 

<i>Opis Listinga 4b:</i> Tabela sadrzi dva dogadjaja. 
- Prvi dogadjaj je @c ID1, tip dogadjaja je struktura @c simpleEvt, koristi  
dinamicki alokator za skladistenje dogadjaja, a opis dogadjaja je: <i>"This is a 
very simple event"</i>.
- Drugi dogadjaj je @c ID2, tip dogadjaja je struktrua @c basicEvt, koristi
dinamicki alokator za skladistenje dogadjaja, a opis dogadjaja je: <i>"A signal 
event"</i>.

U tabeli se prvo navodi identifikator dogadjaja. Identifikator dogadjaja je
enumeratator u C-u. Imena enumeratora se uglavnom pisu velikim slovima. Sledeca 
kolona u tabeli je tip dogadjaja. Tip dogadjaja mora da odgovara nekoj strukturi 
koja je kreirana u prethodnom koraku. Tip dogadjaja se koristi kako bi se 
odredila velicina dogadjaja. Sledecu kolonu cine deskriptori pool memorija za
skladistenje. Zadnja kolona u tabeli je znakovni niz koji opisuje dogadjaj. 
Ukoliko nije potrebno navesti opis onda tu treba da se postavi prazan pokazivac 
na tekst, odnosno, vrednost @c NULL:

@code
#define EVENT_TABLE(table)                                                      \
    table(ID1,      type1_T,        NULL,       NULL)                           \
    table(ID2,      type2_T,        NULL,       NULL)
@endcode
<i>Listing 5</i> - Makro tabela bez opisa dogadjaja

@subsubsection  evtc_step_4 Korak 4: Instaciranje
Prvo se definisu enumeratori dogadjaja.

@code
enum evtId {
    EVENT_TABLE(ES_EXPAND_EVT_ID)
    LAST_EVT_ID
}
@endcode
<i>Listing 6</i> - Instaciranje enumeratora dogadjaja

Zadnji enumerator je LAST_EVT_ID. On se koristi da specificira zadnji 
identifikator dogadjaja. Makro tabela @c EVENT_TABLE sa argumentom 
@ref ES_EXPAND_EVT_ID vrsi transformaciju makro tabele u navodjenje enumeratora. 
Svi identifikatori dogadjaja koji su navedeni u makro tabeli se putem 
@ref ES_EXPAND_EVT_ID makroa transformisu u odgovarajuce enumeratore.

Nakon sto su enumeratori kreirani instacira se sama tabela dogadjaja:

@code
static esEvtDBElem_T gEvtDB[LAST_EVT_ID] = {
    EVENT_TABLE(ES_EXPAND_EVT_DATA)
};
@endcode

@subsection     evt_db_reg Registracija baze dogadjaja

Nakon sto se formira baza dogadjaja ona mora da se registruje. U jednom trenutku 
koristi se samo jedna baza dogadjaja i ona se mora nalaziti u ROM memoriji. 
Registracija kreirane baze dogadjaja se vrsi na sledeci nacin:

@code

    :
    :
    
esEvtDBRegister(
    gEvtDB,
    LAST_EVT_ID);
    
    :
    :
@endcode
@section        evt_configuration Konfiguracija dogadjaja

Za konfiguraciju dogadjaja pogledati @ref evt_cfg.
    
    @section        evt_doc Event (EVT)
@image          html    eSolid_EVT.png
Event (u daljem tekstu EVT) modul vrsi definisanje objekta dogadjaja. Objekat
dogadjaj ima definisane atribute i metode.

Sa obzirom da postoji potreba za dogadjajima koji sadrze veliku kolicinu 
podataka, kopiranje celih dogadjaja postaje izuzetno neefikasan proces. Zbog 
toga se koristi <i>zero-copy</i> politika, gde se ne kopiraju podaci dogadjaja 
vec samo pokazivaci prema njima. Na ovaj nacin se postize vrlo velika propusnost 
sistema.

Dogadjaji poseduju zaglavlje koje definise eSolid i telo koje definise sam
korisnik. Zaglavlje nosi osnovne informacije o samom dogadjaju kao sto su 
identifikator dogadjajaja, velicina i slicno, a u telu dogadjaja se nalaze 
podaci koji se prenose u dogadjaju.

Slanje dogadjaja sa aspekta korisnika se sastoji iz tri faze:
- kreiranje praznog dogadjaja
- popunjavanje tela dogadjaja podacima
- prihvatanje dogadjaja od strane eSolid-a

@subsection     evt_representation Reprezentacija dogadjaja
@image          html    evt_struct.png
Zaglavlje dogadjaja je opisano strukturom: @ref esEvt. 

@section        evt_usage Koriscenje EVT modula
@subsection     evt_defining_evt Definisanje dogadjaja

Pre upotrebe dogadjaja potrebno je definisati zaglavlje dogadjaja. Za defisanje 
zaglavlja dogadjaja koriste se pretprocesorske opcije navedene u datoteci 
@ref kernel_config.h. U zavisnosti od izabranih pretprocesorskih opcija 
zaglavlje dogadjaja moze cuvati razne informacije. Za nadogradjivanje podataka 
na zaglavlje dogadjaja se koristi poseban princip nasledjivanja u C-u. Naime, 
sistem definise strukturu zaglavlja dogadjaja, a programer posredstvom 
nasledjivanja formira dogadjaj sa dodatnim podacima.  

@subsection     evt_create Kreiranje dogadjaja i popunjavanje podacima

Kreiranje praznog dogadjaja se vrsi pozivom funkcije esEvtCreate(). Ova 
funkcija prihvata dva parametara:
- velicina dogadjaja. Ovde se podrazumeva koliko bajtova zauzimaju zaglavlje 
i telo dogadjaja. Sa obzirom da je ponekad tesko dati procenu zauzeca 
podataka u memoriji, kao i zbog vece portabilnosti koda, ovde se preporucuje 
upotreba unarnog operatora @c sizeof.
- identifikator dogadjaja. Svaki dogadjaj je jedinstven i razlikuje se barem 
po identifikatoru. Identifikator je jedinstven broj koji opisuje jednu vrstu 
dogadjaja. Programer moze eksplicitno koristiti brojeve za identifikatore, ali 
se preporucuje upotreba enumeratora jer pruza tu pogodnost da se po imenu 
enumeratora zakljuci sa kojim dogadjajem se radi.

Funkcija vraca pokazivac na memorijski prostor koji je rezervisan za ovaj 
dogadjaj. Zbog ovoga funkcija se ponasa vrlo slicno poznatoj C funkciji 
@c malloc().

Posredstvom dobivenog pokazivaca na rezervisanu memoriju vrsimo popunjavanje
dogadjaja potrebnim podacima. Prilikom kreiranja dogadjaja zaglavlje se 
automatski popunjava podrazumevanim vrednostima.

@subsection     evt_send Slanje dogadjaja EPA objektu

Nako popunjavanja dogadjajima on se moze poslati zeljenom EPA objektu. Slanje
dogadjaja se vrsi funkcijama esEvtPost() koja salje dogadjaj na kraju reda za 
cekanje. To znaci da ce onim redom kojim su pristizali dogadjaji da ce tim redom
i biti obradjeni. Druga alternativna funkcija za slanje dogadjaja je 
esEvtPostAhead() koja postavlja dogadjaj na pocetak reda za cekanje. To znaci da
ce taj dogadjaj biti obradjen pre ostalih dogadjaja.

@subsection     evt_example Primer definisanja, kreiranja i slanja dogadjaja 

U ovoj sekciji koristicemo primer dogadjaja koji se koristi u nekom sistemu. 
Dogadjaj ima identifikator koji je numerisan (enumerator) i neka je taj 
enumerator @c SIG_GET_DATA. Ovaj dogadjaj je tipa @c PARAM_EXCHANGE i sa sobom 
nosi tri korisnicka podatka: @c ID, @c type i @c data. Navedeni podaci se nalaze 
u strukturi koju definise korisnik. Dogadjaj treba da se posalje EPA objektu, 
odnosno, agentu za obradu dogadjaja sa nazivom @c AO_param.

Identifikator dogadjaja (enumerator):
    - SIG_GET_DATA

Tip dogadjaja (enumerator):
    - PARAM_EXCHANGE

Struktura podataka dogadjaja:
    - param.ID
    - param.type
    - param.data

<b>Resenje:</b>

Neka je definicija strukture podataka koji treba da se prenesu jednim dogadjajem 
sledeca:

@code
typedef struct paramData {
    uint8_t     ID
    uint8_t     type
    uint16_t    data
} paramData_T;
@endcode

Za prenos gore navedene strukture treba da se definise struktura dogadjaja koja 
se sastoji od zaglavlja @c header, koju definise sistem, i korisnicke strukture 
podataka @c param, koju definise aplikacija:

@code
typedef struct paramExchange {
    esEvtHeader_T   header;
    paramData_T     param;
} paramExchange_T;
@endcode

Medjutim, potrebno je preneti i podatak o tipu dogadjaja (PARAM_EXCHANGE). Ova 
informacija se ne prenosi putem zaglavlja dogadjaja pa je zato potrebno ručno 
ugraditi i ovu informaciju u strukturu paramExchange_T:

@code
typedef struct paramExchange {
    esEvtHeader_T   header;
    enum evtType    type;
    paramData_T     param;
} paramExchange_T;
@endcode

Sledi primer kreiranja dogadjaja tipa @c paramExchange_T sa signalom 
@c SIG_GET_DATA. Najpre je potrebno definisati pokazivac na dogadjaj, a 
zatim kreiramo nov, prazan dogadjaj velicine @c paramExchange_T, sa 
identifikatorom @c SIG_GET_DATA.

@code
paramExchange_T * pEvt;
pEvt = (paramExchange_T *)esEvtCreate(
    sizeof(paramExchange_T),
    (esEvtID_T)SIG_GET_DATA);
@endcode

Zbog kraceg pisanja uveden je pomocni makro EOT_PLN_CREATE koji prihvata tip 
dogadjaja i identifikator dogadjaja. Makro se koristi na sledeci nacin:

@code
paramExchange_T * pEvt;
pEvt = ES_EVT_CREATE(paramExchange_T, SIG_GET_DATA);
@endcode

Nakon sto je kreiran nov dogadjaj, treba se izvrsiti njegovo popunjavanje 
podacima.

Zaglavlje moze da cuva sledece informacije: identifikator, generator dogadjaja, 
vremenski marker nastanka dogadjaja i zauzece dogadjaja. 

Upis tipa dogadjaja se vrsi na sledeci nacin:

@code
pEvt->type = PARAM_EXCHANGE;
@endcode

Sa ovim smo izvrsili popunjavanjem informacija koje opisuju dogadja,a sada se 
prelazi na popunjavanje ostalim korisnickim podacima:

@code
pEvt->param.ID   = AVENT_SPEED3;
pEvt->param.type = TYPE1;
pEvt->param.data = 0;
@endcode

Sada su zaglavlje i telo dogadjaja potpuno popunjeni podacima. Medjutim, 
dogadjaj jos nije poslat, samo je kreiran. Da bi se ovako kreiran dogadjaj 
poslao potrebno je pozvati funkcuju esEvtPost() ili esEvtPostAhead(). 
Funkcija prihvata sledece parametre:
- pokazivac na agenta za obradu dogadjaja (EPA) i 
- pokazivac na prethodno definisan dogadjaj.

@code
esEvtPost(
    AO_param,
    (esEvtHeader_T *)pEvt);
@endcode

Funkcija prihvata parametre i dogadjaj prosledjuje navedenom agentu za obradu 
dogadjaja.

@subsection     evt_recv_evt Primanje dogadjaja

Primanje dogadjaja se obavlja automatski od strane sistema. Kada EPA objekat 
dodje na red za izvrsenje njemu se predaje dogadjaj na obradu preko parametra.
U funkciji stanja korisnik treba da koristi @c switch-case strukturu kako bi
odredio o kakvom se dogadjaju radi.
*/