/** @file */
/** @defgroup   evt Event Management */
/** @{
@defgroup       evt_intf API
@defgroup       evt_impl Implementation
@defgroup       evt_cfg  Configuration
@}
*/
/** @addtogroup evt
@brief          Event object overview

@section        evt_index Sadrzaj
- @ref evt_intro
- @ref evt_database
    - @ref evt_db_create
    - @ref evt_db_reg
- @ref evt_configuration

@section        evt_intro Dogadjaj i prelazak
Događaj je pojava stimulusa koji može da okine promenu stanja i koji je značajan 
objektu ili aplikaciji.

Kao što se skup objekata definiše klasom čiji su oni uzorci, događaji se 
definišu tipom događaja čije uzorke predstavljaju događaji.

Ono što se modeluje zapravo su tipovi događaja, ali jednostavno ih zovemo 
događajima.

Događaj može imati parametre 

@section        evt_database Baza dogadjaja

eSolid definise centralizovanu bazu dogadjaja koji se koriste u sistemu. Baza 
dogadjaja omogucuje efikasno i jednostavno opisivanje dogadjaja. Podaci su 
staticni, ne menjaju se u toku izvrsavanja aplikacije i zbog toga se podaci mogu 
cuvati u ROM tipu memorije. Baza dogadjaja definise sledece aspekte dogadjaja:
- znakovni identifikator: u C-u se identifikator implementira kao enumerator
- velicinu dogadjaja: za svaki tip dogadjaja se cuva velicina dogadjaja u 
    bajtovima
- memorijsko skladiste dogadjaja: memorijski prostor dogadjaja se moze dobaviti
    upotrebom @c dinamickog alokatora ili upotrebom @c pool alokatora. Ako se
    koristi @c pool alokator onda ovaj clan elementa baze dogadjaja cuva koja
    instanca @c pool alokatora cuva dati tip dogadjaja.
- tip dogadjaja: definise se C tip dogadjaja za svaki dogadjaj. Nekoliko 
    dogadjaja mogu imati isti tip.
- znakovni niz tipa dogadjaja: pored C tipa dogadjaja definise se znakovni niz
    koji se koristi za debug-ovanje
- znakovni niz opisa dogadjaja: kratak opis dogadjaja, sta on radi i za sta se
    koristi.
    
Baza dogadjaja omogucuje eSolid-u da jednostavno poveze identifikator dogadjaja 
sa njegovim ostalim atributuma. Naime, ako se eSolid-u preda samo identifikator 
dogadjaja, on moze da iz baze dogadjaja dobavi ostale atribute o dogadjaju kao 
sto je velicina, memorijsko skladiste, tip, opis dogadjaja i slicno.

@subsection     evt_db_create Kreiranje i popunjavanje baze dogadjaja

Za implementaciju baze dogadjaja koriste se takozvani <i>X makroi</i>. X 
makroima se vrlo jednostavno generise baza dogadjaja i ne postoji mogucnost da 
se pojavi nesklad izmedju identifikatora dogadjaja i ostalih atributa o 
dogadjaju.

Kreiranje i popunjavanje baze dogadjaja se vrsi u nekoliko koraka:
- @ref evtc_step_1
- @ref evtc_step_2
- @ref evtc_step_3
- @ref evtc_step_4

@subsubsection  evtc_step_1 Korak 1: Definisanje tipova
Najpre se vrsi definisanje tipova dogadjaja. Tipovi dogadjaja su samo one 
struktrure koje su izvedene iz osnovne strukture dogadjaja @ref esEvt_T. 
Definisanje se radi na sledeci nacin:
- razmatra se sta je potrebno da dogadjaj prenese, odnosno, koje informacije
    neki dogadjaj treba da nosi sa sobom. Ove informacije se zovu parametri
    dogadjaja.
- kreira se struktura koja nosi ime novog tipa dogadjaja, sa elementima koji su
    odredjeni u prethodnom koraku. Zatim se tim elementima dodaje element 
    zaglavlja dogadjaja @ref esEvt_T koji mora da bude na prvoj poziciji. Ime
    tog elementa nije od znacaja, ali se preporucuju imena kao sto su @c super 
    ili @c header.
    
Primer 1:
- Dogadjaj treba da prenese jedan 32-bitni neoznaceni podatak. Ime novog tipa 
    dogadjaja neka je @c simpleEvt_T.

@code
typedef struct simpleEvt {
    esEvt_T         super;
    uint32_t        data;
} simpleEvt_T;
@endcode
<i>Listing 1</i> - Primer tipa dogadjaja sa jednim parametrom

Primer 2:
- Dogadjaj treba da prenese dva podatka, jedan je 8-bitni, a drugi 16-bitni.
    Oba podatka su neoznacena. Ukoliko je raspored podataka unutar strukture 
    nebitan, onda se preporucuje da se prvo navedu podaci koji zauzimaju veci 
    broj bajtiova, a zatim se navode podaci sa manjim zauzecem. Ovo pomaze 
    kompajlerima da kompaktnije organizuju strukture. Neka je ime novog tipa 
    dogadjaja @c moreComplex_T.
    
@code
typedef struct moreComplex {
    esEvt_T         super;
    uint16_t        data1;
    uint8_t         data2;
} moreComplex_T;
@endcode
<i>Listing 2</i> - Primer tipa dogadjaja sa dva parametra

Primer 3:
- Dogadjaj ne treba da prenese ni jedan parametar. Uglavnom se ovakvi dogadjaji
koriste samo za signalizaciju. Neka je tip takvog dogadjaja @c basicEvt_T.

@code
typedef struct basicEvt {
    esEvt_T         super;
} basicEvt_T;
@endcode
<i>Listing 3</i> - Primer tipa dogadjaja bez parametra

@subsubsection  evtc_step_2 Korak 2: Definisanje memorijskog skladista
Svaka instanca dogadjaja zahteva memorijski prostor. Memorijski prostor se moze
dobaviti upotrebom dva memorijska alokatora, @c dinamicki alokator i @c pool
alokator. @c Dinamicki alokator moze da alocira memorijske regione sa 
promenljivom velicinom, dok @c pool alokator alocira memoriju samo u blokovima 
fiksne velicine. 

- Dinamicki alokator je vrlo slican standardnoj biblioteckoj funkciji @c malloc
sa tom razlikom sto je optimizovan za embedded okruzenje. Medjutim, upotreba 
dinamickog alokatora nije uvek pozeljna u embedded okruzenju zbog nemogucnosti
dokazivanja da ce alokator uvek uspesno opsluziti zahteve za dobavljanje 
memorije.
- Pool alokator je dosta jednostavniji od dinamickog alokatora, ne postoji 
mogucnost pojave fragmentacije memorije i vreme izvrsenja je uvek poznato. 
Glavna negativna osobina je da ne moze da alocira delove memorije vece od 
predefinisane velicine bloka.
 
Ako se koristi pool alokator onda treba kreirati potrebne instance pool 
alokatora (pogledati @ref page_mem), a zatim se deskriptori pool memorija navode
u makro tabeli.

Ukoliko je potrebno da neki dogadjaj ima promenljivu velicinu onda se moze
koristiti dinamicki alokator. U tom slucaju se samo postavlja @c NULL vrednost
umesto pokazivaca na instancu pool alokatora. Dinamicki alokator se 
inicijalizuje na sledeci nacin:

@code

    :
    :

#define BUFFER_SIZE                     1024

    :
    
static char buffer[BUFFER_SIZE];
esDMemInit(
    &gEvtDynStorage,
    &buffer[0],
    sizeof(buffer));
@endcode

@note           Pogledati opcije @ref OPT_EVT_USE_MEM_POOL i 
                @ref OPT_EVT_USE_MEM_DYN kojima se ukljucuje/iskljucuje koji
                alokatori se koriste.
                
@subsubsection  evtc_step_3 Korak 3: Popunjavanje atributa
Nakon definisanja tipova dogadjaja vrsi se popunjavanje svih atributa dogadjaja 
u makro tabelu. 

@code
#define EVENT_TABLE(table)                                                      \
    table({id},     {type},         {storage},  "description")
@endcode
<i>Listing 4a</i> - Format makro tabele 
- @c id - identifikator dogadjaja, tip podatka je @ref esEvtId_T
- @c type - struktura dogadjaja kreirana u @ref evtc_step_1
- @c storage - pokazivac na memorijsko skladiste dogadjaja kreirano u 
    @ref evtc_step_1,
- @c description - znakovni niz kratkog opisa dogadjaja, sta on radi i za sta se
    koristi
    
Podaci se upisuju u makro tabelu na sledeci nacin:

@code
#define EVENT_TABLE(table)                                                      \
    table(ID1,      simpleEvt_T,    NULL,       "This is a very simple event")  \
    table(ID2,      basicEvt_T,     NULL,       "A signal event")
@endcode
<i>Listing 4b</i> - Primer makro tabele sa dva dogadjaja 

<i>Opis Listinga 4b:</i> Tabela sadrzi dva dogadjaja. 
- Prvi dogadjaj je @c ID1, tip dogadjaja je struktura @c simpleEvt, koristi  
dinamicki alokator za skladistenje dogadjaja, a opis dogadjaja je: <i>"This is a 
very simple event"</i>.
- Drugi dogadjaj je @c ID2, tip dogadjaja je struktrua @c basicEvt, koristi
dinamicki alokator za skladistenje dogadjaja, a opis dogadjaja je: <i>"A signal 
event"</i>.

U tabeli se prvo navodi identifikator dogadjaja. Identifikator dogadjaja je
enumeratator u C-u. Imena enumeratora se uglavnom pisu velikim slovima. Sledeca 
kolona u tabeli je tip dogadjaja. Tip dogadjaja mora da odgovara nekoj strukturi 
koja je kreirana u prethodnom koraku. Tip dogadjaja se koristi kako bi se 
odredila velicina dogadjaja. Sledecu kolonu cine deskriptori pool memorija za
skladistenje. Zadnja kolona u tabeli je znakovni niz koji opisuje dogadjaj. 
Ukoliko nije potrebno navesti opis onda tu treba da se postavi prazan pokazivac 
na tekst, odnosno, vrednost @c NULL:

@code
#define EVENT_TABLE(table)                                                      \
    table(ID1,      type1_T,        NULL,       NULL)                           \
    table(ID2,      type2_T,        NULL,       NULL)
@endcode
<i>Listing 5</i> - Makro tabela bez opisa dogadjaja

@subsubsection  evtc_step_4 Korak 4: Instaciranje
Prvo se definisu enumeratori dogadjaja.

@code
enum evtId {
    EVENT_TABLE(ES_EXPAND_EVT_ID)
    LAST_EVT_ID
}
@endcode
<i>Listing 6</i> - Instaciranje enumeratora dogadjaja

Zadnji enumerator je LAST_EVT_ID. On se koristi da specificira zadnji 
identifikator dogadjaja. Makro tabela @c EVENT_TABLE sa argumentom 
@ref ES_EXPAND_EVT_ID vrsi transformaciju makro tabele u navodjenje enumeratora. 
Svi identifikatori dogadjaja koji su navedeni u makro tabeli se putem 
@ref ES_EXPAND_EVT_ID makroa transformisu u odgovarajuce enumeratore.

Nakon sto su enumeratori kreirani instacira se sama tabela dogadjaja:

@code
static esEvtDBElem_T gEvtDB[LAST_EVT_ID] = {
    EVENT_TABLE(ES_EXPAND_EVT_DATA)
};
@endcode

@subsection     evt_db_reg Registracija baze dogadjaja

Nakon sto se formira baza dogadjaja ona mora da se registruje. U jednom trenutku 
koristi se samo jedna baza dogadjaja i ona se mora nalaziti u ROM memoriji. 
Registracija kreirane baze dogadjaja se vrsi na sledeci nacin:

@code

    :
    :
    
esEvtDBRegister(
    gEvtDB,
    LAST_EVT_ID);
    
    :
    :
@endcode
@section        evt_configuration Konfiguracija dogadjaja

Za konfiguraciju dogadjaja pogledati @ref evt_cfg.
    
*/